<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Chip 'n Dale - Pixel Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        .game-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            padding: 10px;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            max-height: 80vh;
            border: 4px solid #333;
            border-radius: 12px;
            background: #64b5f6;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.7);
            border-radius: 20px;
            width: 100%;
            max-width: 400px;
        }

        .control-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(145deg, #4a5568, #2d3748);
            border: 4px solid #e2e8f0;
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 0 #1a202c, 0 10px 20px rgba(0,0,0,0.3);
            transition: all 0.1s;
            position: relative;
            overflow: hidden;
        }

        .control-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #1a202c, 0 6px 10px rgba(0,0,0,0.2);
        }

        .control-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(255,255,255,0.2), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .control-btn:active::after {
            opacity: 1;
        }

        .jump-btn {
            background: linear-gradient(145deg, #38a169, #2f855a);
            border-color: #9ae6b4;
        }

        .ui-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .ui-item {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .ui-icon {
            width: 24px;
            height: 24px;
            background: currentColor;
            border-radius: 4px;
        }

        .score-icon { background: #fbbf24; }
        .heart-icon { background: #ef4444; }
        .level-icon { background: #8b5cf6; }
        .coin-icon { background: #f59e0b; }

        .music-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            border: 2px solid white;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        .music-btn:active {
            transform: scale(0.95);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            z-index: 20;
            display: none;
            border: 4px solid #fbbf24;
            max-width: 90%;
            backdrop-filter: blur(10px);
        }

        .game-over h2 {
            font-size: 32px;
            margin-bottom: 15px;
            color: #fbbf24;
        }

        .game-over p {
            font-size: 18px;
            margin-bottom: 20px;
            color: #e2e8f0;
        }

        .restart-btn {
            background: linear-gradient(145deg, #3b82f6, #1d4ed8);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .restart-btn:active {
            transform: scale(0.95);
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: white;
            font-size: 14px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            max-width: 400px;
        }

        @media (max-width: 480px) {
            .control-btn {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }
            
            .controls {
                gap: 15px;
                padding: 12px;
            }
            
            .ui-item {
                font-size: 16px;
                padding: 6px 12px;
            }
            
            .game-over h2 {
                font-size: 28px;
            }
        }

        @media (max-height: 700px) {
            canvas {
                max-height: 70vh;
            }
            
            .controls {
                margin-top: 10px;
            }
        }

        /* Анимация пульсации для новых уровней */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .level-up {
            animation: pulse 0.5s ease-in-out 3;
        }

        /* Предотвращение выделения текста при долгом нажатии */
        .no-select {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="no-select">
    <div class="game-container">
        <div class="ui-panel">
            <div class="ui-item">
                <div class="ui-icon score-icon"></div>
                <span id="score">0</span>
            </div>
            <div class="ui-item">
                <div class="ui-icon heart-icon"></div>
                <span id="lives">5</span>
            </div>
            <div class="ui-item">
                <div class="ui-icon level-icon"></div>
                <span id="level">1/5</span>
            </div>
            <div class="ui-item">
                <div class="ui-icon coin-icon"></div>
                <span id="coins">0</span>
            </div>
        </div>

        <button class="music-btn" id="musicToggle">♪</button>

        <canvas id="gameCanvas"></canvas>

        <div class="controls">
            <button class="control-btn" id="leftBtn">←</button>
            <button class="control-btn jump-btn" id="jumpBtn">↑</button>
            <button class="control-btn" id="rightBtn">→</button>
        </div>

        <div class="instructions">
            Нажмите кнопки для управления. M - музыка. Долгое нажатие для непрерывного движения.
        </div>

        <div class="game-over" id="gameOverScreen">
            <h2 id="gameOverTitle">GAME OVER</h2>
            <p id="gameOverMessage">Нажмите кнопку ниже, чтобы начать заново</p>
            <button class="restart-btn" id="restartBtn">ИГРАТЬ СНОВА</button>
        </div>
    </div>

    <script>
        // Константы игры
        const SCREEN_WIDTH = 640;
        const SCREEN_HEIGHT = 480;
        const TILE_SIZE = 32;
        const GRAVITY = 0.8;
        const JUMP_FORCE = -16;
        const PLAYER_SPEED = 5;
        const JUMP_COOLDOWN = 15;
        const FPS = 60;

        // Цвета
        const COLORS = {
            BLACK: [0, 0, 0],
            WHITE: [255, 255, 255],
            RED: [200, 30, 30],
            GREEN: [30, 180, 30],
            BLUE: [30, 100, 200],
            BROWN: [150, 100, 50],
            YELLOW: [220, 200, 30],
            SKY_BLUE: [100, 180, 255],
            PURPLE: [160, 50, 200]
        };

        // Генератор звуков
        class SoundGenerator {
            static makeStereo(buffer) {
                const stereo = new Float32Array(buffer.length * 2);
                for (let i = 0; i < buffer.length; i++) {
                    stereo[i * 2] = buffer[i];
                    stereo[i * 2 + 1] = buffer[i];
                }
                return stereo;
            }

            static generateSquareWave(frequency, duration, volume = 0.3, sampleRate = 22050) {
                const samples = Math.floor(sampleRate * duration);
                const buffer = new Float32Array(samples);
                const period = sampleRate / frequency;
                
                for (let i = 0; i < samples; i++) {
                    buffer[i] = Math.sin(2 * Math.PI * frequency * i / sampleRate) > 0 ? 1 : -1;
                }
                
                return buffer.map(v => v * volume);
            }

            static generateTriangleWave(frequency, duration, volume = 0.3, sampleRate = 22050) {
                const samples = Math.floor(sampleRate * duration);
                const buffer = new Float32Array(samples);
                const period = sampleRate / frequency;
                
                for (let i = 0; i < samples; i++) {
                    const phase = (i % period) / period;
                    buffer[i] = 2 * Math.abs(2 * phase - 1) - 1;
                }
                
                return buffer.map(v => v * volume);
            }

            static generateNoise(duration, volume = 0.2, sampleRate = 22050) {
                const samples = Math.floor(sampleRate * duration);
                const buffer = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    buffer[i] = (Math.random() * 2 - 1) * volume;
                }
                
                return buffer;
            }

            static generateSineWave(frequency, duration, volume = 0.3, sampleRate = 22050) {
                const samples = Math.floor(sampleRate * duration);
                const buffer = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    buffer[i] = Math.sin(2 * Math.PI * frequency * i / sampleRate) * volume;
                }
                
                return buffer;
            }

            static generateChord(frequencies, duration, volume = 0.2, sampleRate = 22050) {
                const samples = Math.floor(sampleRate * duration);
                const buffer = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    let sum = 0;
                    for (const freq of frequencies) {
                        sum += Math.sin(2 * Math.PI * freq * i / sampleRate);
                    }
                    buffer[i] = (sum / frequencies.length) * volume;
                }
                
                return buffer;
            }
        }

        // Аудио менеджер
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.musicSource = null;
                this.isMusicPlaying = false;
                this.musicGain = null;
            }

            async initialize() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.musicGain = this.audioContext.createGain();
                    this.musicGain.connect(this.audioContext.destination);
                    this.musicGain.gain.value = 0.3;
                }
                
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                
                this.createSounds();
            }

            createSounds() {
                // Создаем все звуки игры
                this.sounds.jump = this.createSoundBuffer(
                    SoundGenerator.generateSquareWave(523.25, 0.15, 0.2)
                );
                
                this.sounds.collect = this.createSoundBuffer(
                    SoundGenerator.generateChord([659.25, 830.61], 0.2, 0.25)
                );
                
                this.sounds.enemy_hit = this.createSoundBuffer(
                    SoundGenerator.generateSquareWave(220.0, 0.25, 0.3)
                );
                
                this.sounds.hurt = this.createSoundBuffer(
                    SoundGenerator.generateNoise(0.3, 0.25)
                );
                
                this.sounds.level_complete = this.createSoundBuffer(
                    SoundGenerator.generateChord([523.25, 659.25, 783.99], 0.5, 0.3)
                );
                
                this.createBackgroundMusic();
            }

            createSoundBuffer(audioData) {
                if (!this.audioContext) return null;
                
                const buffer = this.audioContext.createBuffer(1, audioData.length, 22050);
                buffer.getChannelData(0).set(audioData);
                return buffer;
            }

            createBackgroundMusic() {
                // Простая 8-битная мелодия
                const melodyNotes = [
                    [523.25, 0.3], [659.25, 0.3], [783.99, 0.3], [659.25, 0.3],
                    [523.25, 0.6], [523.25, 0.3], [440.0, 0.3], [523.25, 0.3],
                    [659.25, 0.6], [659.25, 0.3], [783.99, 0.3], [880.0, 0.3],
                    [987.77, 0.6], [783.99, 0.3], [659.25, 0.3], [523.25, 0.6],
                ];
                
                const sampleRate = 22050;
                let totalSamples = 0;
                for (const [_, duration] of melodyNotes) {
                    totalSamples += Math.floor(sampleRate * duration);
                }
                
                const melodyBuffer = new Float32Array(totalSamples);
                let currentSample = 0;
                
                for (const [freq, duration] of melodyNotes) {
                    const noteSamples = Math.floor(sampleRate * duration);
                    const noteBuffer = SoundGenerator.generateSquareWave(freq, duration, 0.2);
                    
                    // Применяем огибающую
                    const attackLen = Math.min(Math.floor(0.05 * sampleRate), noteSamples);
                    const decayLen = Math.min(Math.floor(0.1 * sampleRate), noteSamples);
                    
                    for (let i = 0; i < noteSamples; i++) {
                        let envelope = 1;
                        if (i < attackLen) {
                            envelope = i / attackLen;
                        } else if (i > noteSamples - decayLen) {
                            envelope = (noteSamples - i) / decayLen;
                        }
                        
                        if (currentSample + i < totalSamples) {
                            melodyBuffer[currentSample + i] = noteBuffer[i] * envelope;
                        }
                    }
                    
                    currentSample += noteSamples;
                }
                
                this.musicBuffer = this.createSoundBuffer(melodyBuffer);
            }

            playSound(soundName) {
                if (!this.audioContext || !this.sounds[soundName]) return;
                
                const source = this.audioContext.createBufferSource();
                source.buffer = this.sounds[soundName];
                
                const gainNode = this.audioContext.createGain();
                gainNode.gain.value = 0.5;
                
                source.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                source.start();
            }

            playBackgroundMusic() {
                if (!this.audioContext || !this.musicBuffer || this.isMusicPlaying) return;
                
                this.musicSource = this.audioContext.createBufferSource();
                this.musicSource.buffer = this.musicBuffer;
                this.musicSource.loop = true;
                this.musicSource.connect(this.musicGain);
                this.musicSource.start();
                this.isMusicPlaying = true;
            }

            stopMusic() {
                if (this.musicSource && this.isMusicPlaying) {
                    this.musicSource.stop();
                    this.isMusicPlaying = false;
                }
            }

            toggleMusic() {
                if (this.isMusicPlaying) {
                    this.stopMusic();
                } else {
                    this.playBackgroundMusic();
                }
                return this.isMusicPlaying;
            }
        }

        // Игровые объекты
        class Player {
            constructor(x, y, audioManager) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 32;
                this.velY = 0;
                this.velX = 0;
                this.onGround = false;
                this.facingRight = true;
                this.animationFrame = 0;
                this.animationTimer = 0;
                this.audio = audioManager;
                this.jumpCooldown = 0;
                this.canJump = true;
            }

            update(platforms, enemies, collectibles) {
                // Обновляем кулдаун прыжка
                if (this.jumpCooldown > 0) {
                    this.jumpCooldown--;
                } else {
                    this.canJump = true;
                }

                // Движение по горизонтали
                this.x += this.velX;

                // Проверка столкновений с платформами по горизонтали
                const playerRect = this.getRect();
                for (const platform of platforms) {
                    if (this.checkCollision(playerRect, platform.rect)) {
                        if (this.velX > 0) {
                            this.x = platform.rect.x - this.width;
                        } else if (this.velX < 0) {
                            this.x = platform.rect.x + platform.rect.width;
                        }
                        break;
                    }
                }

                // Гравитация
                this.velY += GRAVITY;
                this.y += this.velY;

                // Проверка столкновений с платформами по вертикали
                this.onGround = false;
                for (const platform of platforms) {
                    if (this.checkCollision(this.getRect(), platform.rect)) {
                        if (this.velY > 0) {
                            this.y = platform.rect.y - this.height;
                            this.velY = 0;
                            this.onGround = true;
                            this.canJump = true;
                        } else if (this.velY < 0) {
                            this.y = platform.rect.y + platform.rect.height;
                            this.velY = 0;
                        }
                        break;
                    }
                }

                // Анимация
                this.animationTimer++;
                if (this.animationTimer > 10) {
                    this.animationFrame = (this.animationFrame + 1) % 2;
                    this.animationTimer = 0;
                }

                // Ограничение по границам экрана
                if (this.x < 0) this.x = 0;
                if (this.x > SCREEN_WIDTH - this.width) this.x = SCREEN_WIDTH - this.width;
                if (this.y > SCREEN_HEIGHT) {
                    this.y = 100;
                    this.x = 100;
                    this.velY = 0;
                }

                // Проверка сбора предметов
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    if (this.checkCollision(this.getRect(), collectibles[i].getRect())) {
                        collectibles.splice(i, 1);
                        this.audio.playSound('collect');
                        return "collect";
                    }
                }

                // Проверка столкновений с врагами
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (this.checkCollision(this.getRect(), enemies[i].getRect())) {
                        if (this.velY > 0 && this.getRect().bottom < enemies[i].getRect().y + 20) {
                            enemies.splice(i, 1);
                            this.velY = JUMP_FORCE * 0.7;
                            this.audio.playSound('enemy_hit');
                            return "enemy_hit";
                        } else {
                            this.audio.playSound('hurt');
                            return "hurt";
                        }
                    }
                }
                return null;
            }

            jump() {
                if (this.onGround && this.canJump) {
                    this.velY = JUMP_FORCE;
                    this.audio.playSound('jump');
                    this.jumpCooldown = JUMP_COOLDOWN;
                    this.canJump = false;
                    this.onGround = false;
                    return true;
                }
                return false;
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    bottom: this.y + this.height
                };
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            draw(ctx) {
                const color = this.facingRight ? COLORS.BLUE : COLORS.RED;

                // Тело
                this.drawRect(ctx, this.x, this.y, this.width, this.height, color);

                // Голова
                const headY = this.y - 8;
                this.drawRect(ctx, this.x, headY, this.width, 8, color);

                // Уши
                const earY = headY - 6;
                if (this.animationFrame === 0) {
                    this.drawRect(ctx, this.x + 4, earY, 6, 6, color);
                    this.drawRect(ctx, this.x + this.width - 10, earY, 6, 6, color);
                } else {
                    this.drawRect(ctx, this.x + 2, earY, 6, 6, color);
                    this.drawRect(ctx, this.x + this.width - 8, earY, 6, 6, color);
                }

                // Глаза
                const eyeOffset = this.animationFrame === 0 ? 2 : 0;
                const eyeY = headY + 2;
                this.drawRect(ctx, this.x + 6 + eyeOffset, eyeY, 4, 4, COLORS.WHITE);
                this.drawRect(ctx, this.x + this.width - 10 - eyeOffset, eyeY, 4, 4, COLORS.WHITE);
                this.drawRect(ctx, this.x + 8 + eyeOffset, eyeY + 2, 2, 2, COLORS.BLACK);
                this.drawRect(ctx, this.x + this.width - 8 - eyeOffset, eyeY + 2, 2, 2, COLORS.BLACK);

                // Ноги при движении
                if (Math.abs(this.velX) > 0 && this.onGround) {
                    const legOffset = this.animationFrame * 4;
                    this.drawRect(ctx, this.x + 4, this.y + this.height, 4, 6 - legOffset, color);
                    this.drawRect(ctx, this.x + this.width - 8, this.y + this.height, 4, 6 + legOffset, color);
                }
            }

            drawRect(ctx, x, y, w, h, color) {
                ctx.fillStyle = `rgb(${color.join(',')})`;
                ctx.fillRect(x, y, w, h);
            }
        }

        class Platform {
            constructor(x, y, width, height, color = COLORS.BROWN) {
                this.rect = { x, y, width, height };
                this.color = color;
            }

            draw(ctx) {
                ctx.fillStyle = `rgb(${this.color.join(',')})`;
                ctx.fillRect(this.rect.x, this.rect.y, this.rect.width, this.rect.height);

                // Текстура платформы
                for (let i = 0; i < this.rect.width; i += 4) {
                    for (let j = 0; j < this.rect.height; j += 4) {
                        if ((i + j) % 8 === 0) {
                            const darker = this.color.map(c => Math.max(0, c - 30));
                            ctx.fillStyle = `rgb(${darker.join(',')})`;
                            ctx.fillRect(this.rect.x + i, this.rect.y + j, 2, 2);
                        }
                    }
                }
            }
        }

        class Enemy {
            constructor(x, y, patrolRange = 100, level = 1) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 24;
                const baseSpeed = [-2, -1.5, 1.5, 2][Math.floor(Math.random() * 4)];
                this.speed = baseSpeed * (1 + (level - 1) * 0.2);
                this.patrolRange = patrolRange;
                this.startX = x;
                this.animationFrame = 0;
                this.level = level;
            }

            update() {
                this.x += this.speed;
                this.animationFrame = (this.animationFrame + 1) % 30;

                if (Math.abs(this.x - this.startX) > this.patrolRange) {
                    this.speed *= -1;
                }
            }

            getRect() {
                return { x: this.x, y: this.y, width: this.width, height: this.height };
            }

            draw(ctx) {
                const colorBase = this.level < 3 ? [150, 50, 150] : [180, 40, 40];
                const colorAlt = this.level < 3 ? [180, 60, 180] : [220, 60, 60];
                const color = this.animationFrame < 15 ? colorBase : colorAlt;

                ctx.fillStyle = `rgb(${color.join(',')})`;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                const eyeY = this.y + 6;
                if (this.speed > 0) {
                    ctx.fillStyle = `rgb(${COLORS.WHITE.join(',')})`;
                    ctx.fillRect(this.x + this.width - 8, eyeY, 6, 6);
                    ctx.fillStyle = `rgb(${COLORS.RED.join(',')})`;
                    ctx.fillRect(this.x + this.width - 6, eyeY + 2, 3, 3);
                } else {
                    ctx.fillStyle = `rgb(${COLORS.WHITE.join(',')})`;
                    ctx.fillRect(this.x + 2, eyeY, 6, 6);
                    ctx.fillStyle = `rgb(${COLORS.RED.join(',')})`;
                    ctx.fillRect(this.x + 4, eyeY + 2, 3, 3);
                }
            }
        }

        class Collectible {
            constructor(x, y, value = 100) {
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 16;
                this.animationFrame = 0;
                this.value = value;
            }

            update() {
                this.animationFrame = (this.animationFrame + 1) % 60;
            }

            getRect() {
                return { x: this.x, y: this.y, width: this.width, height: this.height };
            }

            draw(ctx) {
                const sizeMod = this.animationFrame < 30 ? 2 : 0;
                let color;
                
                if (this.value === 100) {
                    color = this.animationFrame < 30 ? COLORS.YELLOW : [240, 180, 20];
                } else if (this.value === 200) {
                    color = this.animationFrame < 30 ? [255, 215, 0] : [255, 200, 0];
                } else {
                    color = this.animationFrame < 30 ? COLORS.PURPLE : [180, 50, 220];
                }

                ctx.fillStyle = `rgb(${color.join(',')})`;
                ctx.fillRect(
                    this.x + sizeMod,
                    this.y + sizeMod,
                    this.width - sizeMod * 2,
                    this.height - sizeMod * 2
                );

                ctx.fillStyle = `rgb(${COLORS.BROWN.join(',')})`;
                ctx.fillRect(
                    this.x + this.width / 2 - 2,
                    this.y + 2,
                    4,
                    6
                );
            }
        }

        // Основной класс игры
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = SCREEN_WIDTH;
                this.canvas.height = SCREEN_HEIGHT;
                
                this.audio = new AudioManager();
                this.keys = {};
                this.gameOver = false;
                this.levelComplete = false;
                this.levelCompleteTimer = 0;
                this.lastTime = 0;
                this.accumulator = 0;
                this.frameTime = 1000 / FPS;
                
                this.initializeControls();
                this.resetGame();
                this.start();
            }

            initializeControls() {
                // Кнопки управления
                const leftBtn = document.getElementById('leftBtn');
                const rightBtn = document.getElementById('rightBtn');
                const jumpBtn = document.getElementById('jumpBtn');
                const musicBtn = document.getElementById('musicToggle');
                const restartBtn = document.getElementById('restartBtn');

                // Обработчики для кнопок
                const handleButtonPress = (key, value) => {
                    this.keys[key] = value;
                    if (key === ' ' && value) {
                        this.player.jump();
                    }
                };

                // Нажатие
                leftBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleButtonPress('ArrowLeft', true);
                });
                leftBtn.addEventListener('mousedown', () => handleButtonPress('ArrowLeft', true));

                rightBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleButtonPress('ArrowRight', true);
                });
                rightBtn.addEventListener('mousedown', () => handleButtonPress('ArrowRight', true));

                jumpBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleButtonPress(' ', true);
                });
                jumpBtn.addEventListener('mousedown', () => handleButtonPress(' ', true));

                // Отпускание
                leftBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleButtonPress('ArrowLeft', false);
                });
                leftBtn.addEventListener('mouseup', () => handleButtonPress('ArrowLeft', false));
                leftBtn.addEventListener('mouseleave', () => handleButtonPress('ArrowLeft', false));

                rightBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleButtonPress('ArrowRight', false);
                });
                rightBtn.addEventListener('mouseup', () => handleButtonPress('ArrowRight', false));
                rightBtn.addEventListener('mouseleave', () => handleButtonPress('ArrowRight', false));

                jumpBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleButtonPress(' ', false);
                });
                jumpBtn.addEventListener('mouseup', () => handleButtonPress(' ', false));
                jumpBtn.addEventListener('mouseleave', () => handleButtonPress(' ', false));

                // Музыка
                musicBtn.addEventListener('click', async () => {
                    await this.audio.initialize();
                    const isPlaying = this.audio.toggleMusic();
                    musicBtn.style.background = isPlaying ? 
                        'linear-gradient(145deg, #10b981, #059669)' : 
                        'linear-gradient(145deg, #ef4444, #dc2626)';
                });

                // Рестарт
                restartBtn.addEventListener('click', () => {
                    this.audio.stopMusic();
                    this.resetGame();
                    document.getElementById('gameOverScreen').style.display = 'none';
                });

                // Предотвращение контекстного меню на телефоне
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                // Клавиатура для десктопа
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ') {
                        this.keys[e.key] = true;
                        if (e.key === ' ') {
                            this.player.jump();
                        }
                        e.preventDefault();
                    }
                    if (e.key === 'm' || e.key === 'M') {
                        this.audio.initialize().then(() => {
                            const isPlaying = this.audio.toggleMusic();
                            musicBtn.style.background = isPlaying ? 
                                'linear-gradient(145deg, #10b981, #059669)' : 
                                'linear-gradient(145deg, #ef4444, #dc2626)';
                        });
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ') {
                        this.keys[e.key] = false;
                        e.preventDefault();
                    }
                });
            }

            resetGame() {
                this.score = 0;
                this.lives = 5;
                this.coins = 0;
                this.currentLevel = 1;
                this.gameOver = false;
                this.levelComplete = false;
                this.levelCompleteTimer = 0;
                
                this.player = new Player(100, 100, this.audio);
                this.platforms = [];
                this.enemies = [];
                this.collectibles = [];
                
                this.generateLevel(this.currentLevel);
                this.updateUI();
            }

            generateLevel(level) {
                // Очищаем предыдущие объекты
                this.platforms = [];
                this.enemies = [];
                this.collectibles = [];

                // Базовые платформы
                this.platforms.push(new Platform(0, SCREEN_HEIGHT - 40, SCREEN_WIDTH, 40));
                this.platforms.push(new Platform(100, 350, 200, 20));
                this.platforms.push(new Platform(350, 280, 150, 20));
                this.platforms.push(new Platform(200, 200, 120, 20));
                this.platforms.push(new Platform(450, 150, 100, 20));

                // Уровневая сложность
                const enemyCount = Math.min(3 + level, 8);
                const collectibleCount = Math.min(5 + level * 2, 15);

                // Враги
                for (let i = 0; i < enemyCount; i++) {
                    const x = 100 + Math.random() * (SCREEN_WIDTH - 200);
                    const y = 100 + Math.random() * 200;
                    const patrolRange = 50 + Math.random() * 100;
                    this.enemies.push(new Enemy(x, y, patrolRange, level));
                }

                // Собираемые предметы
                for (let i = 0; i < collectibleCount; i++) {
                    const x = 50 + Math.random() * (SCREEN_WIDTH - 100);
                    const y = 50 + Math.random() * (SCREEN_HEIGHT - 150);
                    const value = Math.random() > 0.7 ? 200 : 100;
                    this.collectibles.push(new Collectible(x, y, value));
                }

                // Выход с уровня (специальный предмет)
                this.collectibles.push(new Collectible(SCREEN_WIDTH - 80, 80, 500));
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = `${this.currentLevel}/5`;
                document.getElementById('coins').textContent = this.coins;
            }

            update() {
                if (this.gameOver || this.levelComplete) return;

                // Управление игроком
                if (this.keys['ArrowLeft']) {
                    this.player.velX = -PLAYER_SPEED;
                    this.player.facingRight = false;
                } else if (this.keys['ArrowRight']) {
                    this.player.velX = PLAYER_SPEED;
                    this.player.facingRight = true;
                } else {
                    this.player.velX = 0;
                }

                // Обновление врагов
                for (const enemy of this.enemies) {
                    enemy.update();
                }

                // Обновление собираемых предметов
                for (const collectible of this.collectibles) {
                    collectible.update();
                }

                // Обновление игрока и проверка столкновений
                const result = this.player.update(this.platforms, this.enemies, this.collectibles);
                
                if (result === "collect") {
                    this.score += 100;
                    this.coins++;
                    this.updateUI();
                    
                    // Проверка завершения уровня
                    if (this.collectibles.length === 0) {
                        this.levelComplete = true;
                        this.levelCompleteTimer = 60;
                        this.audio.playSound('level_complete');
                        document.getElementById('level').classList.add('level-up');
                        setTimeout(() => {
                            document.getElementById('level').classList.remove('level-up');
                        }, 1500);
                    }
                } else if (result === "enemy_hit") {
                    this.score += 200;
                    this.updateUI();
                } else if (result === "hurt") {
                    this.lives--;
                    this.updateUI();
                    
                    if (this.lives <= 0) {
                        this.gameOver = true;
                        this.showGameOver(false);
                    }
                }

                // Обработка завершения уровня
                if (this.levelComplete) {
                    this.levelCompleteTimer--;
                    if (this.levelCompleteTimer <= 0) {
                        if (this.currentLevel < 5) {
                            this.currentLevel++;
                            this.generateLevel(this.currentLevel);
                            this.player.x = 100;
                            this.player.y = 100;
                            this.player.velX = 0;
                            this.player.velY = 0;
                            this.levelComplete = false;
                            this.updateUI();
                        } else {
                            this.gameOver = true;
                            this.showGameOver(true);
                        }
                    }
                }
            }

            showGameOver(isWin) {
                const gameOverScreen = document.getElementById('gameOverScreen');
                const title = document.getElementById('gameOverTitle');
                const message = document.getElementById('gameOverMessage');
                
                if (isWin) {
                    title.textContent = "ПОБЕДА!";
                    message.textContent = `Вы прошли все уровни! Финальный счет: ${this.score}`;
                } else {
                    title.textContent = "GAME OVER";
                    message.textContent = `Игра окончена. Ваш счет: ${this.score}`;
                }
                
                gameOverScreen.style.display = 'block';
            }

            draw() {
                // Очистка экрана
                this.ctx.fillStyle = `rgb(${COLORS.SKY_BLUE.join(',')})`;
                this.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                // Облака на заднем плане
                this.drawBackground();

                // Рисуем все объекты
                for (const platform of this.platforms) {
                    platform.draw(this.ctx);
                }

                for (const enemy of this.enemies) {
                    enemy.draw(this.ctx);
                }

                for (const collectible of this.collectibles) {
                    collectible.draw(this.ctx);
                }

                this.player.draw(this.ctx);

                // Эффект завершения уровня
                if (this.levelComplete) {
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.3 * Math.sin(Date.now() / 200) + 0.3})`;
                    this.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT / 2 - 50, 300, 100);
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 24px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('УРОВЕНЬ ПРОЙДЕН!', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 10);
                    
                    if (this.currentLevel < 5) {
                        this.ctx.font = '16px Courier New';
                        this.ctx.fillText(`Следующий уровень: ${this.currentLevel + 1}`, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 20);
                    } else {
                        this.ctx.font = '16px Courier New';
                        this.ctx.fillText('ФИНАЛ!', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 20);
                    }
                }

                // Эффект получения урона
                if (this.lives < 3) {
                    const intensity = (3 - this.lives) * 0.1;
                    this.ctx.fillStyle = `rgba(255, 0, 0, ${intensity * Math.sin(Date.now() / 300)})`;
                    this.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                }
            }

            drawBackground() {
                // Облака
                const time = Date.now() / 10000;
                for (let i = 0; i < 5; i++) {
                    const x = (time * 50 + i * 150) % (SCREEN_WIDTH + 200) - 100;
                    const y = 50 + i * 40;
                    const size = 40 + i * 10;
                    
                    this.ctx.fillStyle = `rgba(255, 255, 255, 0.7)`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.arc(x + size * 0.7, y - size * 0.3, size * 0.8, 0, Math.PI * 2);
                    this.ctx.arc(x + size * 1.4, y, size * 0.9, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            gameLoop(currentTime) {
                if (!this.lastTime) this.lastTime = currentTime;
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                this.accumulator += deltaTime;

                while (this.accumulator >= this.frameTime) {
                    this.update();
                    this.accumulator -= this.frameTime;
                }

                this.draw();
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            async start() {
                await this.audio.initialize();
                this.lastTime = performance.now();
                this.gameLoop(this.lastTime);
            }
        }

        // Запуск игры при загрузке страницы
        window.addEventListener('load', () => {
            new Game();
        });

        // Предотвращение масштабирования при двойном тапе
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Предотвращение скролла при касании канваса
        document.addEventListener('touchmove', (e) => {
            if (e.target === document.getElementById('gameCanvas')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Адаптация к ориентации экрана
        function handleOrientation() {
            const isPortrait = window.innerHeight > window.innerWidth;
            const gameContainer = document.querySelector('.game-container');
            
            if (isPortrait) {
                gameContainer.style.maxWidth = '100%';
                document.querySelector('.controls').style.maxWidth = '100%';
            } else {
                gameContainer.style.maxWidth = '640px';
                document.querySelector('.controls').style.maxWidth = '400px';
            }
        }

        window.addEventListener('resize', handleOrientation);
        window.addEventListener('orientationchange', handleOrientation);
        handleOrientation();
    </script>
</body>
</html>
